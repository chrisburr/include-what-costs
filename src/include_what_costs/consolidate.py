"""Consolidate external dependencies analysis."""

import json
import tempfile
from dataclasses import dataclass, field
from pathlib import Path

from .benchmark import BenchmarkResult, benchmark_header
from .graph import IncludeGraph, build_reverse_edges


@dataclass
class ExternalHeaderInfo:
    """Information about an external header and its includers."""

    header: str
    direct_includer_count: int
    direct_includers: list[str] = field(default_factory=list)


@dataclass
class ConsolidateResult:
    """Result of consolidation analysis."""

    pattern: str
    external_headers: list[ExternalHeaderInfo]
    synthetic_header_content: str
    benchmark_result: BenchmarkResult | None = None


def find_external_headers_with_includers(
    graph: IncludeGraph,
    pattern: str,
    prefixes: list[str],
) -> list[ExternalHeaderInfo]:
    """Find external headers matching pattern and their direct includers.

    Args:
        graph: The include graph.
        pattern: Substring pattern to match in header paths.
        prefixes: List of path prefixes to identify "our" headers.

    Returns:
        List of ExternalHeaderInfo sorted by includer count (descending).
    """
    # Find headers matching the pattern
    matching_headers = {h for h in graph.all_headers if pattern in h}

    # Find headers matching our prefixes
    prefix_matching = {
        h for h in graph.all_headers if any(h.startswith(p) for p in prefixes)
    }

    # Build reverse edges to find parents
    child_to_parents = build_reverse_edges(graph)

    # For each matching external header, find prefix-matching direct includers
    results: list[ExternalHeaderInfo] = []
    for header in matching_headers:
        direct_includers = sorted(
            p for p in child_to_parents.get(header, set()) if p in prefix_matching
        )
        if direct_includers:  # Only include if actually used by our code
            results.append(
                ExternalHeaderInfo(
                    header=header,
                    direct_includer_count=len(direct_includers),
                    direct_includers=direct_includers,
                )
            )

    # Sort by includer count descending, then by header name
    results.sort(key=lambda x: (-x.direct_includer_count, x.header))
    return results


def generate_synthetic_header(headers: list[str]) -> str:
    """Generate C++ header that includes all external headers.

    Args:
        headers: List of header paths to include.

    Returns:
        C++ header content as a string.
    """
    lines = [
        "// Synthetic header for consolidation benchmark",
        "// Auto-generated by include-what-costs",
        "#pragma once",
        "",
    ]
    for header in sorted(headers):
        lines.append(f'#include "{header}"')
    lines.append("")
    return "\n".join(lines)


def run_consolidate(
    graph: IncludeGraph,
    pattern: str,
    prefixes: list[str],
    compile_flags: str,
    wrapper: str | None = None,
    output_path: Path | None = None,
) -> ConsolidateResult:
    """Run the consolidation analysis workflow.

    Args:
        graph: The include graph.
        pattern: Substring pattern to match external headers.
        prefixes: List of path prefixes identifying "our" headers.
        compile_flags: Compiler flags for benchmarking.
        wrapper: Optional wrapper command.
        output_path: Optional path to write JSON output.

    Returns:
        ConsolidateResult with analysis and benchmark data.
    """
    # Find external headers with their includers
    external_headers = find_external_headers_with_includers(graph, pattern, prefixes)

    if not external_headers:
        print(f'No external headers found matching pattern "{pattern}"')
        return ConsolidateResult(
            pattern=pattern,
            external_headers=[],
            synthetic_header_content="",
            benchmark_result=None,
        )

    # Print results
    print(f'\n=== External Headers Matching "{pattern}" ===\n')

    total_relationships = 0
    for info in external_headers:
        print(f"{info.header} ({info.direct_includer_count} includers)")
        # Show first few includers
        max_show = 5
        for includer in info.direct_includers[:max_show]:
            # Show relative path from prefix for readability
            display_path = includer
            for prefix in prefixes:
                if includer.startswith(prefix):
                    display_path = includer[len(prefix) :].lstrip("/")
                    break
            print(f"  - {display_path}")
        if len(info.direct_includers) > max_show:
            print(f"  ... ({len(info.direct_includers) - max_show} more)")
        print()
        total_relationships += info.direct_includer_count

    # Generate synthetic header
    all_external = [info.header for info in external_headers]
    synthetic_content = generate_synthetic_header(all_external)

    print("=== Synthetic Header ===")
    print(f"Total external headers: {len(all_external)}")
    print(f"Total direct include relationships: {total_relationships}")

    # Benchmark the synthetic header
    print("\n=== Benchmark Result ===")
    work_dir = Path(tempfile.mkdtemp(prefix="iwc_consolidate_"))
    synthetic_path = work_dir / "consolidated.h"
    synthetic_path.write_text(synthetic_content)

    benchmark_result = benchmark_header(
        str(synthetic_path),
        compile_flags,
        work_dir,
        "prmon",
        wrapper,
    )

    if benchmark_result.success:
        print(f"RSS: {benchmark_result.max_rss_kb / 1024:,.0f} MB")
        print(f"Time: {benchmark_result.wall_time_s:.1f}s")
    else:
        print(f"Benchmark failed: {benchmark_result.error}")

    result = ConsolidateResult(
        pattern=pattern,
        external_headers=external_headers,
        synthetic_header_content=synthetic_content,
        benchmark_result=benchmark_result,
    )

    # Write JSON output if requested
    if output_path:
        output_data = {
            "pattern": pattern,
            "external_headers": [
                {
                    "header": info.header,
                    "direct_includer_count": info.direct_includer_count,
                    "direct_includers": info.direct_includers,
                }
                for info in external_headers
            ],
            "synthetic_header": synthetic_content,
            "benchmark": {
                "max_rss_kb": benchmark_result.max_rss_kb,
                "wall_time_s": benchmark_result.wall_time_s,
                "success": benchmark_result.success,
                "error": benchmark_result.error,
            }
            if benchmark_result
            else None,
        }
        with open(output_path, "w") as f:
            json.dump(output_data, f, indent=2)
        print(f"\nWrote {output_path}")

    return result
